1. Functional Requirements

    1.1 Управление Пользователями и Аутентификацией
        - Регистрация: Пользователь регистрируется с помощью Имени, Фамилии, Email и Пароля.
        - Авторизация: Вход в систему по Email и Паролю.
        - Профиль: У пользователя есть профиль (Имя, Фамилия, Email, фото).
        - Безопасность: Возможность выхода из системы и сброса пароля через Email.

    1.2 Управление Проектами
        - Проект: Основная сущность, представляющая проблему для поиска компромисса. Имеет название и описание.
        - Роли в проекте:
            a. Администратор (1 на проект): Создает, редактирует, удаляет проект. Приглашает/удаляет экспертов. Может вносить свое экспертное мнение.  
            b. Эсперт (много на проект): Участвует в проекте по приглашению. Может вносить/редактировать/удалять свое мнение.
        - Приглашение: Администратор добавляет экспертов в проект по уникальной ссылке.

    1.3 Процесс Расчета Компромисса
        - Ввод данных: Участники (администратор и эксперты) вводят свое мнение в виде треугольного числа ("Оптимистическое", "Наиболее вероятное", "Пессимистическое") и указывают свою должность/позицию.
        - Расчет: Система в реальном времени автоматически рассчитывает компромиссное решение по методу BeCoMe после каждого добавления/изменения мнения.
        - Отображение: Актуальное компромиссное решение и мнения всех экспертов видны всем участникам проекта на странице проекта.
        - Жизненный цикл: Все данные (проекты, участники, мнения) сохраняются в базе данных. Старое мнение при редактировании заменяется новым.


2. Non-Functional Requirements

    2.1 Доступность (Availability):
        - Цель: Ты указала 99.9%. Это означает не более ~43 минут простоя в месяц.
        - Надежность данных: "никакие данные не должны быть потеряны". Решается выбором надежной СУБД и настройкой резервного копирования.

    2.2 Согласованность (Consistency):
        - Ключевой момент: Нам важнее гарантия учета последних изменений в данных, чем скорость.Cистема должна обладать Strong Consistency (Строгой согласованностью). То есть, если эксперт А изменил свое мнение, эксперт Б, обновив страницу, должен гарантированно увидеть это изменение. Это подталкивает нас к выбору реляционных баз данных (SQL).

    2.3 Производительность (Performance / Latency):
        - Расчет: "мгновенно (<1 секунды)". Логика метода BeCoMe (по сути, агрегация и усреднение) очень проста и быстра. Даже для 1000 экспертов расчет на сервере займет миллисекунды.
        - Загрузка страниц: "< 2-3 секунд" — стандартный и достижимый показатель.

    2.4 Масштабируемость (Scalability):
        - Рост пользователей: Система должна быть готова к росту, нам нужна "горизонтально масштабируемая" архитектура. В Azure это значит, что мы должны иметь возможность легко добавить мощности нашему веб-серверу или базе данных.
        - Проекты с 1000 экспертами: С точки зрения расчета это не проблема. Проблема может возникнуть в отображении - загружать и рендерить на странице таблицу с 1000 строк может быть медленно для браузера. Это решается на уровне фронтенда, например, с помощью пагинации (показывать экспертов по 50 на странице). Так что бэкенд справится, фронтенд нужно будет спроектировать с учетом пагинации.

    2.5 Безопасность (Security):
        - Данные "в пути": Использовать HTTPS (SSL-сертификат) для шифрования всего трафика между браузером и сервером.
        - Данные "в покое": Современные облачные базы данных (как Azure SQL) шифруют данные на диске по умолчанию (Transparent Data Encryption).
        - Пароли: Никогда не хранить пароли в открытом виде. Использовать хэширование с "солью" (алгоритмы bcrypt или Argon2). Все современные фреймворки умеют это "из коробки".
        - Защита от атак: Использование современных фреймворков (как последние версии Flask/Django для бэкенда и React для фронтенда) уже дает базовую защиту от SQL-инъекций и XSS. Azure также предоставляет встроенные средства защиты (Web Application Firewall).

3. Оценка нагрузки и объема данных (Capacity Estimation)

    - DAU (активные пользователи в день): 1 000
    - MAU (активные пользователи в месяц): 10 000
    - Новых проектов в день: 5
    - Экспертов на проект (в среднем): 20
    - Соотношение Чтение/Запись: 10:1

    3.1 Расчет нагрузки на запись (Write RPS - Requests Per Second):
        - Создание проектов: 5 проектов в день.
        - Добавление мнений: 5 проектов/день * (20 экспертов + 1 админ) = 105 участников/день. Каждый вводит 3 числа. Предположим, это 3 отдельных запроса к API. Итого: 105 * 3 = 315 записей мнений в день.
        - Суммарно: ~320 операций записи в день.
        - Пиковая нагрузка: Трафик идет в рабочие часы (8 часов = 28,800 секунд). Распределим все записи на это время: 320 / 28,800 ≈ 0.01 RPS.
        - Даже если все 1000 пользователей одновременно решат что-то записать в течение одной минуты, это будет 1000 / 60 ≈ 17 RPS.
        - Вывод по нагрузке на запись: Нагрузка очень низкая. Любая, даже самая дешевая конфигурация сервера и базы данных в Azure, справится с этим с огромным запасом.
    
    3.2 Расчет нагрузки на чтение (Read RPS):
        - При соотношении 10:1 пиковая нагрузка на чтение будет 17 RPS (запись) * 10 = 170 RPS (чтение).
        - Реальный расчет: Каждый раз, когда кто-то вносит изменение, все остальные N участников проекта должны получить обновление. Если в проекте 20 человек, то одна запись генерирует ~20 чтений (пересчет и доставка результата). Это более реалистичная модель.
        - Пиковая нагрузка на чтение: 17 (записей в сек) * 20 (участников) ≈ 340 RPS.
        - Вывод по нагрузке на чтение: 340 RPS — это уже заметная, но все еще умеренная нагрузка. Azure App Service и Azure SQL легко справятся с ней, но это уже нужно учитывать при выборе тарифного плана.

    3.3 Расчет объема данных (за 1 год):
        - Пользователи: 10,000 пользователей * (Имя 50б + Фамилия 50б + Email 50б + Хэш пароля 60б + ID 8б + URL фото 250б) ≈ 10,000 * 500 байт = 5 МБ.
        - Проекты: 5 проектов/день * 365 дней ≈ 1825 проектов. 1825 * (Название 200б + Описание 2000б + ID 8б + ID админа 8б) ≈ 1825 * 2.2 КБ ≈ 4 МБ.
        - Мнения экспертов (основной объем): 1825 проектов * 21 участник * (ID 8б + ID проекта 8б + ID юзера 8б + 3 * float(8б) + Должность 100б) ≈ 38,325 мнений * 150 байт ≈ 5.8 МБ.
        - Вывод по объему данных: Суммарный объем данных за год будет в районе 15-20 МБ. С учетом индексов, логов и прочего, пусть будет 100 МБ. Это очень маленький объем.

