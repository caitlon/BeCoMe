### Непреложные Правила Строгого ООП на Python

Ваша мантра: **"Ясность, предсказуемость и строгие контракты превыше всего".**

#### 1. Класс: Только для Связи Данных и Поведения

*   **Правило:** Класс создается только тогда, когда у вас есть **неразделимая** совокупность состояния (данных) и поведения (методов), оперирующих этим состоянием.
    *   **НЕЛЬЗЯ:** Создавать класс только для группировки функций (для этого есть модули).
    *   **НЕЛЬЗЯ:** Создавать класс для хранения простых, неизменяемых данных без специфического поведения (для этого есть `typing.NamedTuple` или `@dataclass(frozen=True)`).
    *   **НУЖНО:** Создавать класс, когда объект проходит через жизненный цикл, меняет свое состояние, и это состояние влияет на результат его методов. *Пример: объект `DatabaseConnection`, который может быть в состояниях `disconnected`, `connected`, `closed`.*

#### 2. Инкапсуляция: Абсолютный Контроль над Состоянием

*   **Правило:** Ни один атрибут объекта **никогда** не должен изменяться извне напрямую. Прямой доступ — это нарушение инкапсуляции. Доступ к состоянию осуществляется только через публичный интерфейс (методы и свойства).
    *   **ИСПОЛЬЗУЙТЕ ОДНО ПОДЧЕРКИВАНИЕ `_`:** Все атрибуты состояния должны быть объявлены с префиксом `_` (например, `self._balance`). Это общепринятое соглашение о том, что атрибут является внутренней деталью реализации.
    *   **ИСПОЛЬЗУЙТЕ `@property` ДЛЯ ЧТЕНИЯ:** Для предоставления доступа на чтение к внутреннему состоянию используйте декоратор `@property`. Это позволяет обращаться к данным как к атрибуту (`my_account.balance`), но под капотом будет вызываться метод.

        ```python
        class Account:
            def __init__(self, initial_balance: float):
                self._balance = initial_balance

            @property
            def balance(self) -> float:
                """Предоставляет доступ только на чтение к балансу."""
                return self._balance
        ```
    *   **ИСПОЛЬЗУЙТЕ МЕТОДЫ ДЛЯ ИЗМЕНЕНИЯ СОСТОЯНИЯ:** Любое изменение состояния должно происходить через публичные методы с говорящими именами (`deposit(amount)`, `withdraw(amount)`). Эти методы инкапсулируют всю логику и проверки. **Избегайте сеттеров (`@balance.setter`)**, если только они не содержат сложной логики валидации или триггеров. Простой сеттер — это признак плохого дизайна.

#### 3. Полиморфизм и Наследование: Строго по Контракту

*   **Правило:** Наследование используется **только** для установления отношения "является" (is-a) и реализации полиморфизма. Все вариации поведения должны быть определены через общий интерфейс, заданный в абстрактном базовом классе.
    *   **ИСПОЛЬЗУЙТЕ `abc.ABC` И `@abc.abstractmethod`:** Чтобы определить строгий контракт для семейства классов, создайте абстрактный базовый класс, унаследованный от `abc.ABC`. Все общие методы, которые должны быть реализованы в подклассах, помечайте декоратором `@abc.abstractmethod`. Это не просто рекомендация — Python не позволит создать экземпляр класса, если хотя бы один абстрактный метод не будет переопределен. Это ваш главный аргумент в пользу формализма.

        ```python
        from abc import ABC, abstractmethod

        class Shape(ABC):
            @abstractmethod
            def area(self) -> float:
                pass

        class Square(Shape):
            def __init__(self, side: float):
                self.side = side
            
            def area(self) -> float:
                return self.side ** 2

        # s = Shape()  # TypeError: Can't instantiate abstract class Shape
        ```
    *   **КОМПОЗИЦИЯ ПРЕВЫШЕ НАСЛЕДОВАНИЯ:** Если отношение не "является", а "имеет" (has-a) или "использует" (uses-a), категорически используйте композицию. *Пример: `Car` не "является" двигателем (`Engine`), он "имеет" двигатель. `car = Car(engine=DieselEngine())`.*

#### 4. Декораторы: Усиление ООП-Паттернов

Декораторы в Python — это синтаксический сахар для реализации многих ООП-паттернов. Их использование демонстрирует глубокое понимание языка.
*   **`@property`:** Как уже сказано, это ваш главный инструмент для инкапсуляции данных.
*   **`@classmethod`:** Используйте для создания методов, которые работают с классом, а не с экземпляром. Идеально подходит для реализации альтернативных конструкторов (паттерн "Фабричный метод").

    ```python
    from datetime import date

    class Person:
        def __init__(self, name: str, age: int):
            self.name = name
            self.age = age

        @classmethod
        def from_birth_year(cls, name: str, birth_year: int) -> 'Person':
            age = date.today().year - birth_year
            return cls(name, age) # Вызываем основной конструктор
    ```
*   **`@staticmethod`:** Используйте для служебных функций, логически связанных с классом, но не зависящих ни от состояния класса, ни от состояния экземпляра. Часто это вспомогательные утилиты.
*   **`@dataclass`:** Используйте для классов, которые являются структурами данных. Это показывает, что вы знаете о современных инструментах Python и не пишете лишний код. Обязательно используйте с `frozen=True` для создания неизменяемых объектов, что является хорошей практикой.

#### 5. Строгая Типизация и Документация

*   **Правило:** Каждая переменная, каждый атрибут, каждый параметр и каждое возвращаемое значение **должны** иметь аннотацию типа. Используйте модуль `typing` для сложных типов (`List`, `Dict`, `Optional`, `Callable`).
*   **Правило:** Каждый класс и каждый публичный метод **должны** иметь docstring в строгом формате (например, Google Style или reStructuredText). Это часть определения публичного интерфейса.

### "Пуленепробиваемый" пример

Давайте соберем все это в один класс, который будет сложно раскритиковать. Он будет реализовывать паттерн "Стратегия" для форматирования отчетов.

```python
from __future__ import annotations
from abc import ABC, abstractmethod
from typing import List, Dict, Any
from dataclasses import dataclass

# 1. Собственные исключения для четкой обработки ошибок
class ReportGenerationError(Exception):
    """Базовый класс для ошибок генерации отчетов."""
    pass

# 2. Использование Dataclass для структуры данных
@dataclass(frozen=True)
class SaleRecord:
    """Неизменяемый объект, представляющий запись о продаже."""
    item_id: str
    amount: float
    quantity: int

# 3. Абстрактный базовый класс (ABC) для определения контракта (Стратегии)
class FormatterStrategy(ABC):
    """Абстрактный класс для стратегий форматирования отчетов."""
    
    @abstractmethod
    def format(self, data: List[SaleRecord]) -> str:
        """Форматирует список записей в строку."""
        pass

# 4. Конкретные реализации стратегий
class JsonFormatter(FormatterStrategy):
    """Форматирует отчет в JSON."""
    def format(self, data: List[SaleRecord]) -> str:
        import json
        # dataclasses легко преобразуются в словари
        return json.dumps([d.__dict__ for d in data], indent=2)

class CsvFormatter(FormatterStrategy):
    """Форматирует отчет в CSV."""
    def format(self, data: List[SaleRecord]) -> str:
        lines = ["item_id,amount,quantity"]
        for record in data:
            lines.append(f"{record.item_id},{record.amount},{record.quantity}")
        return "\n".join(lines)

# 5. Основной класс, использующий композицию и строгую инкапсуляцию
class ReportGenerator:
    """
    Генерирует отчеты о продажах, используя выбранную стратегию форматирования.
    """
    def __init__(self, data: List[SaleRecord]):
        self._data = data  # "Приватный" атрибут
        self._formatter: FormatterStrategy = JsonFormatter() # Стратегия по умолчанию

    def set_formatter(self, formatter: FormatterStrategy) -> None:
        """Публичный метод для смены стратегии."""
        if not isinstance(formatter, FormatterStrategy):
            raise TypeError("Formatter must be a subclass of FormatterStrategy.")
        self._formatter = formatter
        
    def generate(self) -> str:
        """Основной метод, делегирующий работу объекту-стратегии."""
        if not self._data:
            raise ReportGenerationError("No data to generate report.")
        return self._formatter.format(self._data)

    @property
    def record_count(self) -> int:
        """@property для получения вычисляемого значения."""
        return len(self._data)

```
