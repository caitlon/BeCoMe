#### S — Принцип Единственной Ответственности (Single Responsibility Principle)

*   **Суть принципа:** У класса должна быть только одна причина для изменения.
*   **Как это реализуется в Python (и в книге):**
    1.  **Маленькие, сфокусированные классы:** Книга постоянно рефакторит большие классы, разбивая их на более мелкие. Например, вместо одного гигантского класса `Classifier`, в кейс-стади появляются `TrainingData`, `Hyperparameter`, `Distance`. Каждый из них отвечает за свою часть: один за данные, другой за параметры, третий за алгоритм вычисления расстояния.
    2.  **Функции и модули:** В Python ответственность может лежать не только на классе, но и на модуле. Если у вас есть группа функций, которые вместе решают одну задачу (например, парсинг определенного формата), их можно просто поместить в один модуль, не создавая лишний класс-контейнер.
    3.  **Композиция:** Вся книга пропагандирует идею, что класс-менеджер (например, `ReportGenerator` из моего прошлого ответа) не должен сам выполнять всю работу. Он должен *делегировать* ее другим объектам с единственной ответственностью. `ReportGenerator` отвечает за оркестрацию, а `FormatterStrategy` — за форматирование.

*   **Как это доказать:** Укажите на классы в вашем проекте и скажите: "Этот класс отвечает только за X. Если требования к X изменятся, я поменяю только этот класс. Этот класс отвечает только за Y. И так далее".

#### O — Принцип Открытости/Закрытости (Open/Closed Principle)

*   **Суть принципа:** Программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для изменения.
*   **Как это реализуется в Python (и в книге):**
    1.  **Абстрактные Базовые Классы (ABC) и Паттерн "Стратегия":** Это **главный инструмент** для OCP в Python, и книга посвящает ему много внимания (Главы 6 и 11). Вы создаете абстрактный класс (`Distance` или `FormatterStrategy`), который определяет интерфейс. Ваш основной код (`Hyperparameter`) работает с этой абстракцией. Он *закрыт* для изменений. Чтобы добавить новую функциональность (например, новый алгоритм вычисления расстояния `SorensenDistance`), вы просто создаете новый подкласс. Система *открыта* для расширения.
    2.  **Плагинная архитектура:** Декораторы и функции как объекты первого класса позволяют создавать плагинные системы. Вы можете передать функцию как аргумент, не меняя код, который эту функцию будет вызывать.

*   **Как это доказать:** Покажите свой основной класс, который зависит от абстракции. Затем покажите несколько конкретных реализаций этой абстракции. Скажите: "Чтобы добавить новую функциональность, мне не нужно трогать основной, уже протестированный код. Я просто создам новый класс, реализующий этот интерфейс. Код закрыт для модификации, но открыт для расширения".

#### L — Принцип Подстановки Лисков (Liskov Substitution Principle)

*   **Суть принципа:** Объекты в программе должны быть заменяемы на экземпляры их подтипов без изменения правильности выполнения программы. (Проще говоря: если у вас есть `Square` как подкласс `Rectangle`, он должен вести себя как `Rectangle` во всех контекстах).
*   **Как это реализуется в Python (и в книге):**
    1.  **Duck Typing (Утиная типизация):** На базовом уровне Python реализует это через утиную типизацию ("если что-то крякает как утка..."). Если у объектов одинаковый интерфейс (набор методов), они взаимозаменяемы.
    2.  **`abc.ABC` для строгости:** Чтобы сделать это **формально и надежно**, книга настоятельно рекомендует использовать абстрактные базовые классы. `abc.ABC` гарантирует, что все подклассы будут иметь одинаковый интерфейс, а значит, будут взаимозаменяемы. Это прямое воплощение LSP.
    3.  **`typing.Protocol`:** Для статической проверки (`mypy`) можно использовать протоколы. Они определяют интерфейс, не требуя явного наследования, что является более гибким и "питоничным" способом обеспечить LSP на уровне анализа кода.

*   **Как это доказать:** "Все мои реализации стратегий (например, `JsonFormatter`, `CsvFormatter`) наследуются от одного абстрактного класса `FormatterStrategy` и реализуют его контракт. Поэтому я могу безопасно подставить любую из них в `ReportGenerator`, и программа будет работать корректно. Это и есть Принцип подстановки Лисков".

#### I — Принцип Разделения Интерфейса (Interface Segregation Principle)

*   **Суть принципа:** Клиенты не должны быть вынуждены зависеть от методов, которые они не используют. Лучше много маленьких, специфичных интерфейсов, чем один большой и универсальный.
*   **Как это реализуется в Python (и в книге):**
    1.  **Маленькие `abc.ABC` или `typing.Protocol`:** Вместо одного гигантского абстрактного класса `SuperObject` с 20 методами, создайте несколько маленьких протоколов: `CanBeSaved`, `CanBeSerialized`, `CanBeDrawn`.
    2.  **Множественное наследование от ABC (Mixins):** Класс может реализовывать несколько маленьких интерфейсов через множественное наследование от нескольких ABC. Это гораздо лучше, чем наследование от одного "толстого" класса. Книга показывает это на примере `MailSender` (Глава 3).
    3.  **Гибкость `typing.Protocol`:** Протоколы особенно хороши для ISP. Вам не нужно даже явно наследовать класс от протокола. `mypy` сам определит, что ваш класс соответствует протоколу, если у него есть нужные методы.

*   **Как это доказать:** "Вместо того чтобы заставлять все мои объекты реализовывать один большой интерфейс, я разделил функциональность. Например, этот класс реализует только `CanBeLogged`, а этот — `CanBeValidated`. Клиентский код, которому нужна только валидация, не знает и не зависит от логики логирования".

#### D — Принцип Инверсии Зависимостей (Dependency Inversion Principle)

*   **Суть принципа:** Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
*   **Как это реализуется в Python (и в книге):**
    1.  **Dependency Injection (Внедрение зависимостей):** Это центральная тема. Ваш высокоуровневый класс (`ReportGenerator`) не должен сам создавать низкоуровневые объекты (`JsonFormatter`). Он должен получать их извне, через конструктор.
    2.  **Зависимость от абстракций:** `ReportGenerator` не должен знать о существовании `JsonFormatter` или `CsvFormatter`. Он должен зависеть только от абстракции `FormatterStrategy`.

        ```python
        # ПЛОХО: зависимость от конкретной реализации
        class ReportGenerator:
            def __init__(self, data):
                self._data = data
                self._formatter = JsonFormatter() # Жесткая зависимость!

        # ХОРОШО: зависимость от абстракции, конкретика внедряется извне
        class ReportGenerator:
            def __init__(self, data: List[SaleRecord], formatter: FormatterStrategy):
                self._data = data
                self._formatter = formatter
        
        # Клиентский код решает, какую реализацию использовать
        my_data = [...]
        json_report_gen = ReportGenerator(my_data, JsonFormatter())
        csv_report_gen = ReportGenerator(my_data, CsvFormatter())
        ```
*   **Как это доказать:** "Мой основной бизнес-логический класс `ReportGenerator` ничего не знает о том, как именно данные форматируются — в JSON, CSV или XML. Он зависит только от абстрактного контракта `FormatterStrategy`. Это позволяет мне менять или добавлять форматы (детали), не трогая высокоуровневую логику".